#include "LEDMatrix.h"

#define WIDTH   64
#define HEIGHT  16

LEDMatrix matrix(3,4,5,6,2,10,8,12);     // LEDMatrix(a, b, c, d, oe, r1, stb, clk);

// Display Buffer 128 = 64 * 16 / 8
uint8_t displaybuf[WIDTH *HEIGHT / 8] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    /*0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x01, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
    0x01, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0xE0, 0x07, 0x8F, 0xC7, 0xC7, 0xC7, 0xE0,
    0x00, 0x40, 0x0C, 0xCE, 0x6C, 0x6C, 0x6C, 0xE0, 0x00, 0xE0, 0x0C, 0x0C, 0x6C, 0x6C, 0x6C, 0x60,
    0x01, 0xF0, 0x07, 0x8C, 0x6F, 0xEF, 0xEC, 0x60, 0x23, 0xF8, 0x00, 0xCC, 0x6C, 0x0C, 0x0C, 0x60,
    0x33, 0xF8, 0x0C, 0xCE, 0x6C, 0x6C, 0x6C, 0xE0, 0x3B, 0xF8, 0x07, 0x8F, 0xC7, 0xC7, 0xC7, 0xE0,
    0x3B, 0xF8, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x1B, 0xF8, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
    0x0B, 0xF8, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x07, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,*/
};

// 16 * 8 digital font
const uint8_t digitals[] = {
    0x00, 0x00, 0x00, 0x1C, 0x36, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00, 0x00, // 0
    0x00, 0x00, 0x00, 0x18, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, // 1
    0x00, 0x00, 0x00, 0x3E, 0x63, 0x63, 0x63, 0x06, 0x06, 0x0C, 0x18, 0x30, 0x63, 0x7F, 0x00, 0x00, // 2
    0x00, 0x00, 0x00, 0x3E, 0x63, 0x63, 0x06, 0x1C, 0x06, 0x03, 0x03, 0x63, 0x66, 0x3C, 0x00, 0x00, // 3
    0x00, 0x00, 0x00, 0x06, 0x0E, 0x1E, 0x36, 0x36, 0x66, 0x66, 0x7F, 0x06, 0x06, 0x1F, 0x00, 0x00, // 4
    0x00, 0x00, 0x00, 0x7F, 0x60, 0x60, 0x60, 0x7C, 0x76, 0x03, 0x03, 0x63, 0x66, 0x3C, 0x00, 0x00, // 5
    0x00, 0x00, 0x00, 0x1E, 0x36, 0x60, 0x60, 0x7C, 0x76, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00, 0x00, // 6
    0x00, 0x00, 0x00, 0x7F, 0x66, 0x66, 0x0C, 0x0C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, // 7
    0x00, 0x00, 0x00, 0x3E, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x63, 0x63, 0x3E, 0x00, 0x00, // 8
    0x00, 0x00, 0x00, 0x1C, 0x36, 0x63, 0x63, 0x63, 0x37, 0x1F, 0x03, 0x03, 0x36, 0x3C, 0x00, 0x00, // 9
};

// 16 * 8 p & m letters
const uint8_t pm[] = {
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x3E, // ###### 
    0x3B, //  ### ##
    0x33, //  ##  ##
    0x33, //  ##  ##
    0x33, //  ##  ##
    0x3E, //  ##### 
    0x30, //  ##    
    0x30, //  ##    
    0x30,
    0x00,
    0x00,

     
    0x00,
    0x00,   
    0x00,
    0x00,   
    0x00,
    0x00,
    0x77, // ### ###  ###  1 part
    0x39, //  ###  ###  ## 
    0x31, //  ##   ##   ## 
    0x31, //  ##   ##   ## 
    0x31, //  ##   ##   ## 
    0x31, //  ##   ##   ## 
    0x31, //  ##   ##   ## 
    0x7B, // #### #### ####
    0x00, //    
    0x00,

    
    0x00,
    0x00,  
    0x00,
    0x00,
    0x00,
    0x00,
    0x38, // ### ###  ###  2 part
    0xCC, //  ###  ###  ## 
    0x8C, //  ##   ##   ## 
    0x8C, //  ##   ##   ## 
    0x8C, //  ##   ##   ## 
    0x8C, //  ##   ##   ## 
    0x8C, //  ##   ##   ## 
    0xDE, // #### #### ####
    0x00,
};

// (x, y) top-left position, x should be multiple of 8
void drawDigital(uint16_t x, uint16_t y, uint8_t n)
{
    if ((n >= 10) || (0 != (x % 8))) {
        return;
    }

    uint8_t *pDst = displaybuf + y * (WIDTH / 8) + x / 8;
    const uint8_t *pSrc = digitals + n * 16;
    for (uint8_t i = 0; i < 16; i++) {
        *pDst = *pSrc;
        pDst += WIDTH / 8;
        pSrc++;
    }
}

// (x, y) top-left position, x should be multiple of 8
void drawLetter(uint16_t x, uint16_t y, uint8_t n)
{
    if ((n >= 10) || (0 != (x % 8))) {
        return;
    }

    uint8_t *pDst = displaybuf + y * (WIDTH / 8) + x / 8;
    const uint8_t *pSrc = pm + n * 16;
    for (uint8_t i = 0; i < 16; i++) {
        *pDst = *pSrc;
        pDst += WIDTH / 8;
        pSrc++;
    }
}

void drawPpmValue(uint32_t value) 
{
  matrix.clear();
  uint32_t start = 1;
  if (value >= 1000) {
      start = 0;
  }
  uint8_t place = 3 - start;
  do {
      uint8_t digit = value % 10;
      value /= 10;
      drawDigital(place * 8, 0, digit);
      place--;
  } while (value > 0 && place >= 0);
  

  drawLetter(32 - start * 8, 0, 0);
  drawLetter(40 - start * 8, 0, 0);
  drawLetter(48 - start * 8, 0, 1);
  drawLetter(56 - start * 8, 0, 2);
}

#include <SoftwareSerial.h>

SoftwareSerial mySerial(A0, A1); // A0 - к TX сенсора, A1 - к RX

byte cmd[9] = {0xFF,0x01,0x86,0x00,0x00,0x00,0x00,0x00,0x79}; 
unsigned char response[9];

uint32_t getPpmValue() 
{
  mySerial.write(cmd, 9);
  memset(response, 0, 9);
  mySerial.readBytes(response, 9);
  int i;
  byte crc = 0;
  for (i = 1; i < 8; i++) crc+=response[i];
  crc = 255 - crc;
  crc++;

  if ( !(response[0] == 0xFF && response[1] == 0x86 && response[8] == crc) ) {
    return 0;
  } else {
    unsigned int responseHigh = (unsigned int) response[2];
    unsigned int responseLow = (unsigned int) response[3];
    unsigned int ppm = (256*responseHigh) + responseLow;
    return ppm;
  }
}

void setup()
{
    matrix.begin(displaybuf, WIDTH, HEIGHT);
    matrix.reverse();
    
    Serial.begin(9600);
    mySerial.begin(9600);

    uint32_t ppm = getPpmValue();
    Serial.println(ppm);
    drawPpmValue(ppm);
}

void loop()
{
    static uint32_t lastCountTime = 0;

    matrix.scan();
    if ((millis() - lastCountTime) > 15000) {
        lastCountTime = millis();
        uint32_t ppm = getPpmValue();
        Serial.println(ppm);
        drawPpmValue(ppm);
    }
}



















